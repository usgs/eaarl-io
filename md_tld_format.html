<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>eaarl-io: TLD File Format</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">eaarl-io
   &#160;<span id="projectnumber">1.0.1+71abbd4</span>
   </div>
   <div id="projectbrief">EAARL Input/Output Library (Public API)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">TLD File Format </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>TLD stands for "Type, Length, Data", which describes the general storage paradigm used. Each record starts with a short header than specifies the record length and the record type. Following that is the data, which is interpreted based on the record's type. This library is only concerned with type 5, which is used for EAARL-A and EAARL-B raster data.</p>
<h2>File Format</h2>
<p>A TLD file is a series of variable length records. Each record has two parts:</p>
<ol type="1">
<li>Header, specifying the type and size of the record.</li>
<li>Data, which is to be interpreted based on the record type.</li>
</ol>
<p>The eaarl-io library can decode the header for any record type, but will only decode the data for type = 5 (EAARL-A and EAARL-B raster data).</p>
<p>The data section of a raster record has the following structure:</p>
<ol type="1">
<li>Raster header</li>
<li>Series of pulse records, each of which consist of:<ol type="a">
<li>Pulse header</li>
<li>Waveform data</li>
</ol>
</li>
</ol>
<p>The file stores values in little-endian format.</p>
<h3>Record Header</h3>
<table class="doxtable">
<tr>
<th>Item </th><th>Format </th><th>Size  </th></tr>
<tr>
<td>record_length </td><td>uint24_t </td><td>3 bytes </td></tr>
<tr>
<td>record_type </td><td>uint8_t </td><td>1 byte </td></tr>
</table>
<ul>
<li><b>record_length:</b> The length of the record, including this header.</li>
<li><b>record_type:</b> The type identifier for the record. For EAARL-A and EAARL-B raster data, this is always 5.</li>
</ul>
<p>Note that <em>record_length</em> is more authorative than any length information in the record. If the record suggests that it should be longer than the <em>record_length</em> allows, then the record must be truncated.</p>
<h3>Raster Header</h3>
<table class="doxtable">
<tr>
<th>Item </th><th>Format </th><th>Size  </th></tr>
<tr>
<td>time_seconds </td><td>uint32_t </td><td>4 bytes </td></tr>
<tr>
<td>time_fraction </td><td>uint32_t </td><td>4 bytes </td></tr>
<tr>
<td>sequence_number </td><td>uint32_t </td><td>4 bytes </td></tr>
<tr>
<td>pulse_count and digitizer bitfield </td><td>uint16_t </td><td>2 bytes </td></tr>
</table>
<p>The <em>pulse_count</em> and <em>digitizer</em> fields are stored together in a 2-byte unsigned integer. The <em>pulse_count</em> is the lower 15 bits of the integer. The <em>digitizer</em> is the high bit, 1 or 0. Because the integer is stored in little-endian format, the bit for <em>digitizer</em> is located as the high bit of the second byte when viewing the raw bytes of the file.</p>
<ul>
<li><b>time_seconds:</b> The integer seconds portion of the timestamp for the raster. This needs to be combined with <em>time_fraction</em> to derive the full timestamp.</li>
<li><b>time_fraction:</b> The fractional seconds portion of the timestamp for the raster. This needs to be combined with <em>time_seconds</em> to derive the full timestamp. The value is stored in a hardware-specific format; to convert to seconds, multiply by 1.6e-6.</li>
<li><b>sequence_number:</b> This is a simple sequence number. The value cycles and repeats and is thus not suitable for uniquely identifying rasters. It is not used for anything and should be ignored.</li>
<li><b>pulse_count:</b> Number of pulses in the raster. This specifies how many pulse records will follow.</li>
<li><b>digitizer:</b> The digitizer used for the waveforms, either 0 or 1.</li>
</ul>
<h3>Pulse Header</h3>
<table class="doxtable">
<tr>
<th>Item </th><th>Format </th><th>Size  </th></tr>
<tr>
<td>time_offset </td><td>uint24_t </td><td>3 bytes </td></tr>
<tr>
<td>rx_count </td><td>uint8_t </td><td>1 byte </td></tr>
<tr>
<td>bias_tx </td><td>uint8_t </td><td>1 byte </td></tr>
<tr>
<td>bias_rx </td><td>uint8_t[4] </td><td>4 bytes </td></tr>
<tr>
<td>scan_angle_counts </td><td>int16_t </td><td>2 bytes </td></tr>
<tr>
<td>range, thresh_tx, and thresh_rx bitfield </td><td>uint16_t </td><td>2 bytes </td></tr>
</table>
<p>The <em>range</em>, <em>thresh_tx</em>, and <em>thresh_rx</em> fields are stored together in a 2-byte unsigned integer. The <em>range</em> is the lower 14 bits of the integer. The <em>thresh_tx</em> is bit 15 and <em>thresh_rx</em> is bit 16 (each are 1 or 0). Because the integer is stored in little-endian format, the bits for <em>thresh_tx</em> and <em>thresh_rx</em> are the high bits of the second byte when viewing the raw bytes of the file.</p>
<ul>
<li><b>time_offset:</b> Additional fractional time elapsed since start of raster. The value is stored in a hardware-specific format; to convert to seconds, multiply by 1.6e-6. This needs to be added to the raster's timestamp (<em>time_seconds</em> and <em>time_fraction</em>) to derive the timestamp for the pulse.</li>
<li><b>rx_count:</b> Number of waveforms in the pulse record. This should never exceed 4.</li>
<li><b>bias_tx:</b> Transmit range bias in nanoseconds.</li>
<li><b>bias_rx:</b> Channel range biases in nanoseconds. There are four values regardless of <em>rx_count</em>. If <em>rx_count</em> &lt; 4, then the extra values are meaningless.</li>
<li><b>scan_angle_counts:</b> Angle of the scanner. The value is stored in a hardware-specific format; to convert to degrees, multiply by 0.045.</li>
<li><b>range:</b> Range measurement of the laser pulse, in nanoseconds. This measure the travel time from the mirror to the start of the raster and back.</li>
<li><b>thresh_tx:</b> Transmit waveform hardware threshold failure. 1 indicates that the transmit waveform failed the hardware-defined threshold.</li>
<li><b>thresh_rx:</b> Return waveform hardware threshold failure. 1 indicates that the return waveforms failed the hardware-defined threshold.</li>
</ul>
<h3>Waveform Data</h3>
<table class="doxtable">
<tr>
<th>Item </th><th>Format </th><th>Size  </th></tr>
<tr>
<td>data_length </td><td>uint16_t </td><td>2 bytes </td></tr>
<tr>
<td>data </td><td></td><td>varies per data_length </td></tr>
</table>
<p>The data consists of the transmit waveform followed by up to four return waveforms. The waveform count is as specified by the <em>rx_count</em> field of the pulse header. Each waveform is stored as a length value followed by the waveform data.</p>
<p>The transmit waveform is stored as:</p>
<table class="doxtable">
<tr>
<th>Item </th><th>Format </th><th>Size  </th></tr>
<tr>
<td>tx_len </td><td>uint8_t </td><td>1 byte </td></tr>
<tr>
<td>tx </td><td>unsigned char[] </td><td>varies per tx_len </td></tr>
</table>
<p>Each return waveform is stored as:</p>
<table class="doxtable">
<tr>
<th>Item </th><th>Format </th><th>Size  </th></tr>
<tr>
<td>rx_len </td><td>uint16_t </td><td>2 bytes </td></tr>
<tr>
<td>rx </td><td>unsigned char[] </td><td>varies per rx_len </td></tr>
</table>
<p>Note that <em>data_length</em> is more authoriative than the <em>tx_len</em> and <em>rx_len</em> values. If a waveform's length would extend beyond the space designated by <em>data_length</em>, then it should be truncated.</p>
<h3>Example record</h3>
<p>Follows is an example of how the components all fit together. The example raster has two pulses. The first pulse has one waveform and the second pulse has four waveforms.</p>
<table class="doxtable">
<tr>
<th>Section </th><th>Subsection </th><th>Field  </th></tr>
<tr>
<td>Record Header </td><td></td><td>record_length </td></tr>
<tr>
<td>Record Header </td><td></td><td>record_type </td></tr>
<tr>
<td>Raster Header </td><td></td><td>time_seconds </td></tr>
<tr>
<td>Raster Header </td><td></td><td>time_fraction </td></tr>
<tr>
<td>Raster Header </td><td></td><td>sequence_number </td></tr>
<tr>
<td>Raster Header </td><td></td><td>bitfield </td></tr>
<tr>
<td>Pulse 0 </td><td>Pulse Header </td><td>time_offset </td></tr>
<tr>
<td>Pulse 0 </td><td>Pulse Header </td><td>rx_count </td></tr>
<tr>
<td>Pulse 0 </td><td>Pulse Header </td><td>bias_tx </td></tr>
<tr>
<td>Pulse 0 </td><td>Pulse Header </td><td>bias_rx[4] </td></tr>
<tr>
<td>Pulse 0 </td><td>Pulse Header </td><td>scan_angle_counts </td></tr>
<tr>
<td>Pulse 0 </td><td>Pulse Header </td><td>bitfield </td></tr>
<tr>
<td>Pulse 0 </td><td>Waveform Data </td><td>data_length </td></tr>
<tr>
<td>Pulse 0 </td><td>Waveform Data </td><td>tx_len </td></tr>
<tr>
<td>Pulse 0 </td><td>Waveform Data </td><td>tx[] </td></tr>
<tr>
<td>Pulse 0 </td><td>Waveform Data </td><td>rx_len[0] </td></tr>
<tr>
<td>Pulse 0 </td><td>Waveform Data </td><td>rx[0][] </td></tr>
<tr>
<td>Pulse 1 </td><td>Pulse Header </td><td>time_offset </td></tr>
<tr>
<td>Pulse 1 </td><td>Pulse Header </td><td>rx_count </td></tr>
<tr>
<td>Pulse 1 </td><td>Pulse Header </td><td>bias_tx </td></tr>
<tr>
<td>Pulse 1 </td><td>Pulse Header </td><td>bias_rx[4] </td></tr>
<tr>
<td>Pulse 1 </td><td>Pulse Header </td><td>scan_angle_counts </td></tr>
<tr>
<td>Pulse 1 </td><td>Pulse Header </td><td>bitfield </td></tr>
<tr>
<td>Pulse 1 </td><td>Waveform Data </td><td>data_length </td></tr>
<tr>
<td>Pulse 1 </td><td>Waveform Data </td><td>tx_len </td></tr>
<tr>
<td>Pulse 1 </td><td>Waveform Data </td><td>tx[] </td></tr>
<tr>
<td>Pulse 1 </td><td>Waveform Data </td><td>rx_len[0] </td></tr>
<tr>
<td>Pulse 1 </td><td>Waveform Data </td><td>rx[0][] </td></tr>
<tr>
<td>Pulse 1 </td><td>Waveform Data </td><td>rx_len[1] </td></tr>
<tr>
<td>Pulse 1 </td><td>Waveform Data </td><td>rx[1][] </td></tr>
<tr>
<td>Pulse 1 </td><td>Waveform Data </td><td>rx_len[2] </td></tr>
<tr>
<td>Pulse 1 </td><td>Waveform Data </td><td>rx[2][] </td></tr>
<tr>
<td>Pulse 1 </td><td>Waveform Data </td><td>rx_len[3] </td></tr>
<tr>
<td>Pulse 1 </td><td>Waveform Data </td><td>rx[3][] </td></tr>
</table>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
